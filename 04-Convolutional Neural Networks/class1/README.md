<h1 align="center">第四课第一周“卷积神经网络”</h1>

## 笔记
### 计算机视觉
深度学习有两个令人兴奋的特点：
1. 计算机视觉的高速发展标志着新型应用产生的可能，这是几年前，人们所不敢想象的。通过学习使用这些工具，你也许能够创造出新的产品和应用。
2. 人们对于计算机视觉的研究富有想象力和创造力，由此衍生出新的神经网络结构与算法启发人们去创造出计算机视觉与其他领域的交叉成果。举个例子，语音识别经常从计算机视觉领域中寻找灵感。所以即使你在计算机视觉方面没有做出成果，我也希望你也可以将所学的知识应用到其他算法和结构。

一般的计算机视觉问题包含以下几类：

- 图片分类（Image Classification）；
![Image Classification](01)
- 目标检测（Object detection）；
![Image Classification](02）
- 神经风格转换（Neural Style Transfer）
![Image Classification](03)

在应用计算机视觉是往往面临一个挑战，就是数据的输入可能会很大，比如一张1000x1000x3的图片，特征向量 x 的维度高达 300 万。所以在第一隐藏层中，你也许会有 1000 个隐藏单元，而所有的权值组成了矩阵 $l^{th}$ 。如果你使用了标准的全连接网络，这个矩阵的大小将会是 1000×300 万。因为现在 x 的维度为 3m，3m 通常用来表示 300 万。这意味着矩阵 $W^{[1]}$ 会有 30亿个参数，这是个非常巨大的数字。所以会产生两种后果：
1. 神经网络结构复杂，数据量过少，导致出现过拟合和竞争需求
2. 内存巨大，硬件需求太高

所以对于计算机视觉应用来说，通过卷积计算来处理蕴含着大量数据的图像。

### 卷积运算

卷积运算是卷积神经网络最基本的组成部分，使用边缘检测作为入门样例，来理解卷积是如何进行运算的，根据实验表明，神经网络的前几层是负责如何检测边缘的，然后，后面的层有可能负责检测到物体的部分区域，更靠后的一些层可能负责检测到完整的物体，这个例子中就是人脸。

![Image Classification](04)

#### 边缘检测示例

图片最常做的边缘检测有两类：垂直边缘（Vertical Edges）检测和水平边缘（Horizontal Edges）检测。

![Image Classification](05)

比如上图，图中的栏杆（红色线条）就是属于垂直边缘的范畴，同样的行人的轮廓线（红色线条）也可以理解为垂线，这些先调试垂直边缘检测器的输出，同样，当你想检测水平边缘的时候，图中的栏杆（绿色线条）就是很明显的水平线。

图片的边缘检测可以通过与相应的过滤器进行卷积实现，以垂直边缘检测为例，原始图像是一个 6×6 的灰度图像，因为是灰度图像，所以它是 6×6×1 的矩阵，而不是 6×6×3 的，因为没有 RGB 三通道。为了检测图像中的垂直边缘，现在构造一个 3×3 矩阵。在通用习惯中，在卷积神经网络的术语中，它被称为过滤器（filter），当然有些论文把它叫做“核”。

![Image Classification](06)

卷积运算的求解过程是从左到右，由上到下，每次在原始图片矩阵中取与滤波器同等大小的一部分，每一部分中的值与滤波器中的值对应相乘后求和，将结果组成一个矩阵。就如上图所示：原始图片尺寸为 6x6，过滤器尺寸为 3x3，卷积后得到的图片尺寸为 4x4，得到结果如最右边矩阵（数值表示灰度，以左上角和右下角的值为例）。
下图同样对应一个垂直边缘的例子：

![Image Classification](07)

如果将最右边的矩阵当作图像，那么中间一段亮一些的区域对应最左边的图像中间的垂直边缘。

这是一个动态演示的例子：

![Image Classification](08)

 图中的 `*` 表示卷积运算符号。在计算机中这个符号表示一般的乘法，而在不同的深度学习框架中，卷积操作的 API 定义可能不同：

* 在 Python 中，卷积用 `conv_forward()` 表示；
* 在 Tensorflow 中，卷积用 `tf.nn.conv2d()` 表示；
* 在 keras 中，卷积用 `Conv2D()` 表示。

**为什么这个过滤器可以用做边缘检测呢？**
这是一个简单的 6×6 图像，左边的一半是 10，右边一般是 0。它当成一个图片，左边那部分看起来是白色的，像素值 10 是比较亮的像素值，右边像素值比较暗，使用灰色来表示 0。图片里，有一个特别明显的垂直边缘在图像中间，这条垂直线是从黑到白的过渡线，或者从白色到深色。而3x3 的过滤器就像中间的那副图显示的那样，然后进行卷积运算，得到右边的矩阵。在中间有段亮一点的区域，对应检查到这个 6×6 图像中间的垂直边缘。

![Image Classification](09)

#### 更多边缘检测的内容

那如何区分正边和负边，这实际就是由亮到暗与由暗到亮的区别，也就是边缘的过渡。

这张 6×6 的图片，左边较亮，而右边较暗，将它与垂直边缘检测滤波器进行卷积，检测结果就显示在了右边这幅图的中间部分。

![Image Classification](07)

而这幅图它的颜色被翻转了，变成了左边比较暗，而右边比较亮。如果用相同的过滤器进行卷积，就变成下面图片的样子。中间的过渡部分被翻转，之前的 30 翻转成了-30，表明是由暗向亮过渡，而不是由亮向暗过渡。

![Image Classification](09)

垂直边缘检测和水平边缘检测的滤波器如下所示：

![Image Classification](10)

其他常用的过滤器有叫做Sobel的过滤器和叫做Scharr的过滤器：

![Image Classification](11)

其实在真正的应用中这些 **过滤器的数字正是需要网络学习的参数 w** 。相比这种单纯的垂直边缘和水平边缘，它可以检测出 45°或 70°或 73°，甚至是任何角度的边缘。

#### padding

假设输入图片的大小为 $n \times n$，而滤波器的大小为 $f \times f$，则卷积后的输出图片大小为 $(n-f+1) \times (n-f+1)$。

这样就有两个问题：

- 每次卷积运算后，输出图片的尺寸缩小，图像在每次识别边缘或其他特征时都缩小是不好的现象
- 如下图：像素点（绿色阴影标记）只被一个输出所触碰或者使用，因为它位于这个 3×3 的区域的一角。但如果是在中间的像素点，比如这个（红色方框标记），就会有许多 3×3 的区域与之重叠。所以那些在角落或者边缘区域的像素点在输出中采用较少，意味着你丢掉了图像边缘位置的许多信息。

![Image Classification](12)

为了解决这些问题，可以在进行卷积操作前，对原始图片在边界上进行填充（Padding），以增加矩阵的大小。通常将 0 作为填充值。

![Image Classification](13)

设每个方向扩展像素点数量为 $p$，则填充后原始图片的大小为 $(n+2p) \times (n+2p)$，过滤器大小保持 $f \times $不变，则输出图片大小为 $(n+2p-f+1) \times (n+2p-f+1)$。

因此，在进行卷积运算时，我们有两种选择：

- Valid 卷积：不填充，直接卷积。结果大小为 $(n-f+1) \times (n-f+1)$；
- Same 卷积：进行填充，并使得卷积后结果大小与输入一致，这样 $p = \frac{f-1}{2}$。

在计算机视觉领域，$f$通常为奇数。原因包括 Same 卷积中 $p = \frac{f-1}{2}$能得到自然数结果，并且过滤器有一个便于表示其所在位置的中心点。

#### 卷积步长

卷积中，有时候需要通过padding来避免信息损失，有时候也需要通过设置 **步长（stride）** 来压缩信息。

步长表示过滤器在原始图片的水平方向和垂直方向上每次移动的距离。之前，步长被默认为 1。而如果我们设置步长为 2，则卷积过程如下图所示：

![Image Classification](14)

设步长为 $s$，填充长度为 $p$，输入图片大小为 $n \times n$，过滤器大小为 $f \times $，则卷积后图片的尺寸为：

$$\biggl\lfloor \frac{n+2p-f}{s}+1 \biggr\rfloor \times \biggl\lfloor \frac{n+2p-f}{s}+1 \biggr\rfloor$$

注意公式中有一个向下取整的符号，用于处理商不为整数的情况。向下取整反映着当取原始矩阵的图示蓝框完全包括在图像内部时，才对它进行运算。

目前为止我们学习的“卷积”实际上被称为互相关（cross-correlation），而非数学意义上的卷积。真正的卷积操作在做元素乘积求和之前，要将滤波器沿水平和垂直轴翻转（相当于旋转 180 度）。因为这种翻转对一般为水平或垂直对称的滤波器影响不大，按照机器学习的惯例，我们通常不进行翻转操作，在简化代码的同时使神经网络能够正常工作。

#### 高维卷积

上述讨论均基于灰度图像，也就是二维矩阵，那么在彩色RGB图像上如何卷积呢？
